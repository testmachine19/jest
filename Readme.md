**Инструкция по утановке и запуску тестов с помощью Jest.**

Для начала рабоы необходимо убедиться, что у вас установлен **_NodeJS_** фреймворк, который позволяет работать с проектами.
Это можно сделать вызвав в терминале команду _node -v_:

1. Если он установлен то вы увидите версию NodeJS
2. Если нет - то выйдет сообщение о том, что на машине не найден данный пакет.
3. Если его нет можно вызвать команду через установщик homebrew на macOS и дождаться автоматической установки:

```
brew install node
```

После этого необходимо инициировать в VS файл **.gitignore** - он поможет не отправлять пакеты Node в удаленный репозиторий. Скачать его для Node можно в репозиториях GitHub - их более чем достаточно в открытом доступе. Выбирайте тот, в котором добавлена папка Node modules/

Следующим шагом будет инициирование пакета **package.json**. Для этого в терминале внутри VS необходимо набрать команду npm init.
Далее пошагово заполнить запрашиваемую информацию и получится следующий файл:

```
{
"name": "tmp",
"version": "1.0.0",
"type": "module",
"description": "",
"main": "index.js",
"scripts": {
"test": "echo \"Error: no test specified\" && exit 1"
},
"author": "",
"license": "ISC"
}
```

После данной процедуры нам необходимо установить сам **Jest** для проведения тестов на нашем коде. Для этого в терминале VS вызываем команду:

```
npm install --save-dev jest
```

Чтобы команда вызывалась из терминала необходимо добавить в конфигурацию файла package.json следущий скрипт:

```
{
"scripts": {
"test": "jest"
}
}
```

Он добавляется в поле вместо "echo \"Error: no test specified\" && exit 1".

Это позволит с помощью команды **npx jest** в терминале вопроизводить тесты, для написанного кода и проверять их результаты.

**Мы почти готовы!**

Далее создаем проект (у нас это будет calculateBonus для примера):

1. Создаем файл calculateBonus с расширением js.
2. Пишем в него свою функцию:

```
function calculateBonus(a, b) {
let bonus;
const sum = a + b;
debugger;
sum > 50 ? (bonus = 50) : (bonus = sum);
debugger;
return bonus;
}
```

3. Проверяем с помощью console.log работоспособность функции.

**После необходимо создать еще один файл, в котором мы будем проводить необходимые тесты:**

1. Создаем файл calculateBonus, но прописывем расширение .tets.js. Это необходимо для того, чтобы наш Jest автоматически понимал в каком файле необходимо проводить тесты.
2. Далее необходимо установить зависимости первого и второго файла с помощью простого импорта/экспорта фнукции из одного в другой:

Пишшем в конце первого файла следующий код - **module.exports = calculateBonus**; Он создает экспорт нашей функции из файла.

Во втором файле необходимо прописать прринимающий метод, то есть импорт:

```
const calculateBonus = require("./calculateBonus");
```

**"./calculateBonus"** - здесь является обозначениме относительного пути до файла, где содержится функция. нужен именно относительный путь!

Это достатончо просто сделать:

- пишем "./ и VS сразу покажет в какой папке в оказались. ./ обозначает что вы в той же директории, где и ваш проект (в основном это всегда так). ./.. - поднимет вас на уровень выше, ./../.. - еще выше и так далее до вашего файла.

3. После установления зависимости начинаем писать тесты! В jest это делается через метод test или it:

```
it("Если сумма более 50, то бонус 50", () => {
const result = calculateBonus(30, 25);
expect(result).toBe(50);
});
```

Поскольку наша фнукция расчитывает бонус, который получает сотрудник, то задаеем соответсвующие проверки. Но для начала опишем, что у нас за функция:

**_наша фнукция имеет условие - если первый и второй агрумент в сумме будут иметь более 50, то человек получает бонус = 50. Если сумма первого и второго аргумента менее 50, то человек получает бонус равный сумме аргументов._**

Отсюда, вспоминая техники тест-дизайна, я расписал следующие тесты:

```
it("Если сумма более 50, то бонус 50", () => {
const result = calculateBonus(30, 25);
expect(result).toBe(50);
});

it("Если сумма менее 50, то бонус равен сумме чисел", () => {
const result = calculateBonus(20, 15);
expect(result).toBe(35);
});

it("Если сумма чисел равна 0", () => {
const result = calculateBonus(0, 0);
expect(result).toBe(0);
});

it("Если сумма чисел равна ровно 50", () => {
const result = calculateBonus(25, 25);
expect(result).toBe(50);
});

it("Если сумма более 50 на один", () => {
const result = calculateBonus(11, 40);
expect(result).toBe(50);
});

it("Если сумма чисел менее 50 на один", () => {
const result = calculateBonus(19, 30);
expect(result).toBe(49);
});

it("Если числа отрицательные", () => {
const result = calculateBonus(-19, -30);
expect(result).toBe(0);
});
it("Если 1 из чисел отрицательное", () => {
const result = calculateBonus(-19, 30);
expect(result).toBe(11);
});
```

Можно разобрать любой на следующие составляющие:

_it - метод, который мы задаем для теста, ("Название нашего теста", () => стрелочная функция, которая указывает параметры теста {
const result - задаем результат, который получился (в один из месяцев например) = calculateBonus(-19, 30). И далее вызываем тот самый ожидаем результат через expect(result).toBe(11) - залаем каким он должен быть.
})_

4. Поскоьку у нас много тестов - они могут собираться в **тестовые наборы или Test suit**. В Jest мы можем сделать это с помощью метода describe. Для этого необходимо наши тесты "облачить" в данный метод и выглядит это примерно так:

```
describe("calculateBonus", () => {
it("Если сумма более 50, то бонус 50", () => {
const result = calculateBonus(30, 25);
expect(result).toBe(50);
});
});
```

Задаем метод **describe** и описывем для какого тестового набора он применяется. И внутри метода помещаем все наши тесты (не забудьте правильный порядок скобок, чтобы все сработало).

И вызываем наш тестовый набор - получаем в логах:

```
FAIL ./calculateBonus.test.js
calculateBonus
✓ Если сумма более 50, то бонус 50 (1 ms)
✓ Если сумма менее 50, то бонус равен сумме чисел
✓ Если сумма чисел равна 0
✓ Если сумма чисел равна ровно 50
✓ Если сумма более 50 на один
✓ Если сумма чисел менее 50 на один
✕ Если числа отрицательные (1 ms)
✓ Если 1 из чисел отрицательное (1 ms)

● calculateBonus › Если числа отрицательные

    expect(received).toBe(expected) // Object.is equality

    Expected: 0
    Received: -49

      34 |   it("Если числа отрицательные", () => {
      35 |     const result = calculateBonus(-19, -30);
    > 36 |     expect(result).toBe(0);
         |                    ^
      37 |   });
      38 |   it("Если 1 из чисел отрицательное", () => {
      39 |     const result = calculateBonus(-19, 30);

      at Object.toBe (calculateBonus.test.js:36:20)

Test Suites: 1 failed, 1 total
Tests: 1 failed, 7 passed, 8 total
Snapshots: 0 total
Time: 0.149 s, estimated 1 s
```

Один тест провалился, поскольку я указывал значение 0 при трицательных числах (мы же не будем отнимать деньги сотрудников, если в какой-то момент проект уйдет в минус. Они просто не получат бонус и он будет равен 0). Но система считает, что результатом должно быть отрицательное значение. И это нормально. Такой провалившийся тест также можно считать успешным результатом и правильной работой системы.
